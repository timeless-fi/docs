"use strict";(self.webpackChunktimeless_docs=self.webpackChunktimeless_docs||[]).push([[876],{3905:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>k});var n=a(7294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function u(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var d=n.createContext({}),o=function(t){var e=n.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=o(t.components);return n.createElement(d.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},s=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,d=t.parentName,p=u(t,["components","mdxType","originalType","parentName"]),s=o(a),k=l,N=s["".concat(d,".").concat(k)]||s[k]||m[k]||r;return a?n.createElement(N,i(i({ref:e},p),{},{components:a})):n.createElement(N,i({ref:e},p))}));function k(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=s;var u={};for(var d in e)hasOwnProperty.call(e,d)&&(u[d]=e[d]);u.originalType=t,u.mdxType="string"==typeof t?t:l,i[1]=u;for(var o=2;o<r;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}s.displayName="MDXCreateElement"},7984:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>u,toc:()=>o});var n=a(7462),l=(a(7294),a(3905));const r={sidebar_position:2},i="Gate",u={unversionedId:"smart-contracts/core/Gate",id:"smart-contracts/core/Gate",title:"Gate",description:"GitHub: link",source:"@site/docs/smart-contracts/core/Gate.md",sourceDirName:"smart-contracts/core",slug:"/smart-contracts/core/Gate",permalink:"/docs/smart-contracts/core/Gate",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/smart-contracts/core/intro"},next:{title:"Factory",permalink:"/docs/smart-contracts/core/Factory"}},d={},o=[{value:"Errors",id:"errors",level:2},{value:"Error_InvalidInput",id:"error_invalidinput",level:3},{value:"Error_VaultSharesNotERC20",id:"error_vaultsharesnoterc20",level:3},{value:"Error_TokenPairNotDeployed",id:"error_tokenpairnotdeployed",level:3},{value:"Error_EmergencyExitNotActivated",id:"error_emergencyexitnotactivated",level:3},{value:"Error_SenderNotPerpetualYieldToken",id:"error_sendernotperpetualyieldtoken",level:3},{value:"Error_EmergencyExitAlreadyActivated",id:"error_emergencyexitalreadyactivated",level:3},{value:"Events",id:"events",level:2},{value:"EnterWithUnderlying",id:"enterwithunderlying",level:3},{value:"EnterWithVaultShares",id:"enterwithvaultshares",level:3},{value:"ExitToUnderlying",id:"exittounderlying",level:3},{value:"ExitToVaultShares",id:"exittovaultshares",level:3},{value:"ClaimYieldInUnderlying",id:"claimyieldinunderlying",level:3},{value:"ClaimYieldInVaultShares",id:"claimyieldinvaultshares",level:3},{value:"ClaimYieldAndEnter",id:"claimyieldandenter",level:3},{value:"Structs",id:"structs",level:2},{value:"EmergencyExitStatus",id:"emergencyexitstatus",level:3},{value:"Constants",id:"constants",level:2},{value:"PRECISION_DECIMALS",id:"precision_decimals",level:3},{value:"PRECISION",id:"precision",level:3},{value:"Immutable parameters",id:"immutable-parameters",level:2},{value:"factory",id:"factory",level:3},{value:"State variables",id:"state-variables",level:2},{value:"pricePerVaultShareStored",id:"pricepervaultsharestored",level:3},{value:"yieldPerTokenStored",id:"yieldpertokenstored",level:3},{value:"userYieldPerTokenStored",id:"useryieldpertokenstored",level:3},{value:"userAccruedYield",id:"useraccruedyield",level:3},{value:"emergencyExitStatusOfVault",id:"emergencyexitstatusofvault",level:3},{value:"State-mutating functions",id:"state-mutating-functions",level:2},{value:"enterWithUnderlying",id:"enterwithunderlying-1",level:3},{value:"enterWithVaultShares",id:"enterwithvaultshares-1",level:3},{value:"exitToUnderlying",id:"exittounderlying-1",level:3},{value:"exitToVaultShares",id:"exittovaultshares-1",level:3},{value:"claimYieldInUnderlying",id:"claimyieldinunderlying-1",level:3},{value:"claimYieldInVaultShares",id:"claimyieldinvaultshares-1",level:3},{value:"claimYieldAndEnter",id:"claimyieldandenter-1",level:3},{value:"View functions",id:"view-functions",level:2},{value:"getNegativeYieldTokenForVault",id:"getnegativeyieldtokenforvault",level:3},{value:"getPerpetualYieldTokenForVault",id:"getperpetualyieldtokenforvault",level:3},{value:"getClaimableYieldAmount",id:"getclaimableyieldamount",level:3},{value:"computeYieldPerToken",id:"computeyieldpertoken",level:3},{value:"getUnderlyingOfVault",id:"getunderlyingofvault",level:3},{value:"getPricePerVaultShare",id:"getpricepervaultshare",level:3},{value:"getVaultShareBalance",id:"getvaultsharebalance",level:3},{value:"vaultSharesIsERC20",id:"vaultsharesiserc20",level:3},{value:"negativeYieldTokenName",id:"negativeyieldtokenname",level:3},{value:"negativeYieldTokenSymbol",id:"negativeyieldtokensymbol",level:3},{value:"perpetualYieldTokenName",id:"perpetualyieldtokenname",level:3},{value:"perpetualYieldTokenSymbol",id:"perpetualyieldtokensymbol",level:3},{value:"beforePerpetualYieldTokenTransfer",id:"beforeperpetualyieldtokentransfer",level:3},{value:"Emergency exit functions",id:"emergency-exit-functions",level:2},{value:"ownerActivateEmergencyExitForVault",id:"owneractivateemergencyexitforvault",level:3},{value:"ownerDeactivateEmergencyExitForVault",id:"ownerdeactivateemergencyexitforvault",level:3},{value:"emergencyExitNegativeYieldToken",id:"emergencyexitnegativeyieldtoken",level:3},{value:"emergencyExitPerpetualYieldToken",id:"emergencyexitperpetualyieldtoken",level:3},{value:"Internal functions",id:"internal-functions",level:2},{value:"_accrueYield",id:"_accrueyield",level:3},{value:"_enter",id:"_enter",level:3},{value:"_exit",id:"_exit",level:3},{value:"_claimYield",id:"_claimyield",level:3},{value:"_getClaimableYieldAmount",id:"_getclaimableyieldamount",level:3},{value:"_depositIntoVault",id:"_depositintovault",level:3},{value:"_withdrawFromVault",id:"_withdrawfromvault",level:3},{value:"_vaultSharesAmountToUnderlyingAmount",id:"_vaultsharesamounttounderlyingamount",level:3},{value:"_vaultSharesAmountToUnderlyingAmountRoundingUp",id:"_vaultsharesamounttounderlyingamountroundingup",level:3},{value:"_underlyingAmountToVaultSharesAmount",id:"_underlyingamounttovaultsharesamount",level:3},{value:"_computeYieldPerToken",id:"_computeyieldpertoken",level:3}],p={toc:o};function m(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"gate"},"Gate"),(0,l.kt)("p",null,"GitHub: ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/timeless-fi/timeless/blob/main/src/Gate.sol"},"link")),(0,l.kt)("p",null,"Gate is the main contract users interact with to mint/burn NegativeYieldToken\nand PerpetualYieldToken, as well as claim the yield earned by PYTs."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},'Gate is an abstract contract that should be inherited from in order to support\na specific vault protocol (e.g. YearnGate supports YearnVault). Each Gate handles\nall vaults & associated NYTs/PYTs of a specific vault protocol.\nVaults are yield-generating contracts used by Gate. Gate makes several assumptions about\na vault:\n1) A vault has a single associated underlying token that is immutable.\n2) A vault gives depositors yield denominated in the underlying token.\n3) A vault depositor owns shares in the vault, which represents their deposit.\n4) Vaults have a notion of "price per share", which is the amount of underlying tokens\neach vault share can be redeemed for.\n5) If vault shares are represented using an ERC20 token, then the ERC20 token contract must be\nthe vault contract itself.')),(0,l.kt)("h2",{id:"errors"},"Errors"),(0,l.kt)("h3",{id:"error_invalidinput"},"Error_InvalidInput"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_InvalidInput()\n")),(0,l.kt)("h3",{id:"error_vaultsharesnoterc20"},"Error_VaultSharesNotERC20"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_VaultSharesNotERC20()\n")),(0,l.kt)("h3",{id:"error_tokenpairnotdeployed"},"Error_TokenPairNotDeployed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_TokenPairNotDeployed()\n")),(0,l.kt)("h3",{id:"error_emergencyexitnotactivated"},"Error_EmergencyExitNotActivated"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_EmergencyExitNotActivated()\n")),(0,l.kt)("h3",{id:"error_sendernotperpetualyieldtoken"},"Error_SenderNotPerpetualYieldToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_SenderNotPerpetualYieldToken()\n")),(0,l.kt)("h3",{id:"error_emergencyexitalreadyactivated"},"Error_EmergencyExitAlreadyActivated"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_EmergencyExitAlreadyActivated()\n")),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("h3",{id:"enterwithunderlying"},"EnterWithUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event EnterWithUnderlying(address sender, address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 underlyingAmount)\n")),(0,l.kt)("h3",{id:"enterwithvaultshares"},"EnterWithVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event EnterWithVaultShares(address sender, address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 vaultSharesAmount)\n")),(0,l.kt)("h3",{id:"exittounderlying"},"ExitToUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ExitToUnderlying(address sender, address recipient, address vault, contract IxPYT xPYT, uint256 underlyingAmount)\n")),(0,l.kt)("h3",{id:"exittovaultshares"},"ExitToVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ExitToVaultShares(address sender, address recipient, address vault, contract IxPYT xPYT, uint256 vaultSharesAmount)\n")),(0,l.kt)("h3",{id:"claimyieldinunderlying"},"ClaimYieldInUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ClaimYieldInUnderlying(address sender, address recipient, address vault, uint256 underlyingAmount)\n")),(0,l.kt)("h3",{id:"claimyieldinvaultshares"},"ClaimYieldInVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ClaimYieldInVaultShares(address sender, address recipient, address vault, uint256 vaultSharesAmount)\n")),(0,l.kt)("h3",{id:"claimyieldandenter"},"ClaimYieldAndEnter"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ClaimYieldAndEnter(address sender, address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 amount)\n")),(0,l.kt)("h2",{id:"structs"},"Structs"),(0,l.kt)("h3",{id:"emergencyexitstatus"},"EmergencyExitStatus"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct EmergencyExitStatus {\n  bool activated;\n  uint96 pytPriceInUnderlying;\n}\n")),(0,l.kt)("h2",{id:"constants"},"Constants"),(0,l.kt)("h3",{id:"precision_decimals"},"PRECISION_DECIMALS"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 PRECISION_DECIMALS\n")),(0,l.kt)("p",null,"The decimals of precision used by yieldPerTokenStored and pricePerVaultShareStored"),(0,l.kt)("h3",{id:"precision"},"PRECISION"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 PRECISION\n")),(0,l.kt)("p",null,"The precision used by yieldPerTokenStored and pricePerVaultShareStored"),(0,l.kt)("h2",{id:"immutable-parameters"},"Immutable parameters"),(0,l.kt)("h3",{id:"factory"},"factory"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Factory factory\n")),(0,l.kt)("h2",{id:"state-variables"},"State variables"),(0,l.kt)("h3",{id:"pricepervaultsharestored"},"pricePerVaultShareStored"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => uint256) pricePerVaultShareStored\n")),(0,l.kt)("p",null,"The amount of underlying tokens each vault share is worth, at the time of the last update.\nUses PRECISION."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"vault => value")),(0,l.kt)("h3",{id:"yieldpertokenstored"},"yieldPerTokenStored"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => uint256) yieldPerTokenStored\n")),(0,l.kt)("p",null,"The amount of yield each PYT has accrued, at the time of the last update.\nScaled by PRECISION."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"vault => value")),(0,l.kt)("h3",{id:"useryieldpertokenstored"},"userYieldPerTokenStored"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => mapping(address => uint256)) userYieldPerTokenStored\n")),(0,l.kt)("p",null,"The amount of yield each PYT has accrued, at the time when a user has last interacted\nwith the gate/PYT. Shifted by 1, so e.g. 3 represents 2, 10 represents 9."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"vault => user => value\nThe value is shifted to use 0 for representing uninitialized users.")),(0,l.kt)("h3",{id:"useraccruedyield"},"userAccruedYield"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => mapping(address => uint256)) userAccruedYield\n")),(0,l.kt)("p",null,"The amount of yield a user has accrued, at the time when they last interacted\nwith the gate/PYT (without calling claimYieldInUnderlying()).\nShifted by 1, so e.g. 3 represents 2, 10 represents 9."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"vault => user => value")),(0,l.kt)("h3",{id:"emergencyexitstatusofvault"},"emergencyExitStatusOfVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"mapping(address => struct Gate.EmergencyExitStatus) emergencyExitStatusOfVault\n")),(0,l.kt)("p",null,"Stores info relevant to emergency exits of a vault."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"vault => value")),(0,l.kt)("h2",{id:"state-mutating-functions"},"State-mutating functions"),(0,l.kt)("h3",{id:"enterwithunderlying-1"},"enterWithUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function enterWithUnderlying(address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 underlyingAmount) external virtual returns (uint256 mintAmount)\n")),(0,l.kt)("p",null,"Converts underlying tokens into NegativeYieldToken and PerpetualYieldToken.\nThe amount of NYT and PYT minted will be equal to the underlying token amount."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The underlying tokens will be immediately deposited into the specified vault.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\ndeploy them before proceeding, which will increase the gas cost significantly.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted NYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted PYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to mint NYT and PYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying tokens to use")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mintAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of NYT and PYT minted (the amounts are equal)")))),(0,l.kt)("h3",{id:"enterwithvaultshares-1"},"enterWithVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function enterWithVaultShares(address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 vaultSharesAmount) external virtual returns (uint256 mintAmount)\n")),(0,l.kt)("p",null,"Converts vault share tokens into NegativeYieldToken and PerpetualYieldToken."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Only available if vault shares are transferrable ERC20 tokens.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\ndeploy them before proceeding, which will increase the gas cost significantly.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted NYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted PYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to mint NYT and PYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vaultSharesAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of vault share tokens to use")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mintAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of NYT and PYT minted (the amounts are equal)")))),(0,l.kt)("h3",{id:"exittounderlying-1"},"exitToUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function exitToUnderlying(address recipient, address vault, contract IxPYT xPYT, uint256 underlyingAmount) external virtual returns (uint256 burnAmount)\n")),(0,l.kt)("p",null,"Converts NegativeYieldToken and PerpetualYieldToken to underlying tokens.\nThe amount of NYT and PYT burned will be equal to the underlying token amount."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The underlying tokens will be immediately withdrawn from the specified vault.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\nrevert.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted NYT and PYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to mint NYT and PYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying tokens requested")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"burnAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of NYT and PYT burned (the amounts are equal)")))),(0,l.kt)("h3",{id:"exittovaultshares-1"},"exitToVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function exitToVaultShares(address recipient, address vault, contract IxPYT xPYT, uint256 vaultSharesAmount) external virtual returns (uint256 burnAmount)\n")),(0,l.kt)("p",null,"Converts NegativeYieldToken and PerpetualYieldToken to vault share tokens.\nThe amount of NYT and PYT burned will be equal to the underlying token amount."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Only available if vault shares are transferrable ERC20 tokens.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\nrevert.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted NYT and PYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to mint NYT and PYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vaultSharesAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of vault share tokens requested")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"burnAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of NYT and PYT burned (the amounts are equal)")))),(0,l.kt)("h3",{id:"claimyieldinunderlying-1"},"claimYieldInUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function claimYieldInUnderlying(address recipient, address vault) external virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,"Claims the yield earned by the PerpetualYieldToken balance of msg.sender, in the underlying token."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"If the NYT and PYT for the specified vault haven't been deployed yet, this call will\nrevert.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the yield")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to claim yield from")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"yieldAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of yield claimed, in underlying tokens")))),(0,l.kt)("h3",{id:"claimyieldinvaultshares-1"},"claimYieldInVaultShares"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function claimYieldInVaultShares(address recipient, address vault) external virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,"Claims the yield earned by the PerpetualYieldToken balance of msg.sender, in vault shares."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Only available if vault shares are transferrable ERC20 tokens.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\nrevert.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the yield")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to claim yield from")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"yieldAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of yield claimed, in vault shares")))),(0,l.kt)("h3",{id:"claimyieldandenter-1"},"claimYieldAndEnter"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function claimYieldAndEnter(address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT) external virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,"Claims the yield earned by the PerpetualYieldToken balance of msg.sender, and immediately\nuse the yield to mint NYT and PYT."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Introduced to save gas for xPYT compounding, since it avoids vault withdraws/transfers.\nIf the NYT and PYT for the specified vault haven't been deployed yet, this call will\nrevert.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted NYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pytRecipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the minted PYT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to claim yield from")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"yieldAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of yield claimed, in underlying tokens")))),(0,l.kt)("h2",{id:"view-functions"},"View functions"),(0,l.kt)("h3",{id:"getnegativeyieldtokenforvault"},"getNegativeYieldTokenForVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNegativeYieldTokenForVault(address vault) public view virtual returns (contract NegativeYieldToken)\n")),(0,l.kt)("p",null,"Returns the NegativeYieldToken associated with a vault."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns non-zero value even if the contract hasn't been deployed yet.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"contract NegativeYieldToken"),(0,l.kt)("td",{parentName:"tr",align:null},"The NegativeYieldToken address")))),(0,l.kt)("h3",{id:"getperpetualyieldtokenforvault"},"getPerpetualYieldTokenForVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getPerpetualYieldTokenForVault(address vault) public view virtual returns (contract PerpetualYieldToken)\n")),(0,l.kt)("p",null,"Returns the PerpetualYieldToken associated with a vault."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns non-zero value even if the contract hasn't been deployed yet.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"contract PerpetualYieldToken"),(0,l.kt)("td",{parentName:"tr",align:null},"The PerpetualYieldToken address")))),(0,l.kt)("h3",{id:"getclaimableyieldamount"},"getClaimableYieldAmount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getClaimableYieldAmount(address vault, address user) external view virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,"Returns the amount of yield claimable by a PerpetualYieldToken holder from a vault.\nAccounts for protocol fees."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"user"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The PYT holder to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"yieldAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of yield claimable")))),(0,l.kt)("h3",{id:"computeyieldpertoken"},"computeYieldPerToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function computeYieldPerToken(address vault) external view virtual returns (uint256)\n")),(0,l.kt)("p",null,"Computes the latest yieldPerToken value for a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The latest yieldPerToken value")))),(0,l.kt)("h3",{id:"getunderlyingofvault"},"getUnderlyingOfVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getUnderlyingOfVault(address vault) public view virtual returns (contract ERC20)\n")),(0,l.kt)("p",null,"Returns the underlying token of a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,l.kt)("td",{parentName:"tr",align:null},"The underlying token")))),(0,l.kt)("h3",{id:"getpricepervaultshare"},"getPricePerVaultShare"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getPricePerVaultShare(address vault) public view virtual returns (uint256)\n")),(0,l.kt)("p",null,"Returns the amount of underlying tokens each share of a vault is worth."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The pricePerVaultShare value")))),(0,l.kt)("h3",{id:"getvaultsharebalance"},"getVaultShareBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getVaultShareBalance(address vault) public view virtual returns (uint256)\n")),(0,l.kt)("p",null,"Returns the amount of vault shares owned by the gate."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The gate's vault share balance")))),(0,l.kt)("h3",{id:"vaultsharesiserc20"},"vaultSharesIsERC20"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function vaultSharesIsERC20() public pure virtual returns (bool)\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"True if the vaults supported by this gate use transferrable ERC20 tokens to represent shares, false otherwise.")))),(0,l.kt)("h3",{id:"negativeyieldtokenname"},"negativeYieldTokenName"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function negativeYieldTokenName(address vault) external view virtual returns (string)\n")),(0,l.kt)("p",null,"Computes the ERC20 name of the NegativeYieldToken of a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"The ERC20 name")))),(0,l.kt)("h3",{id:"negativeyieldtokensymbol"},"negativeYieldTokenSymbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function negativeYieldTokenSymbol(address vault) external view virtual returns (string)\n")),(0,l.kt)("p",null,"Computes the ERC20 symbol of the NegativeYieldToken of a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"The ERC20 symbol")))),(0,l.kt)("h3",{id:"perpetualyieldtokenname"},"perpetualYieldTokenName"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function perpetualYieldTokenName(address vault) external view virtual returns (string)\n")),(0,l.kt)("p",null,"Computes the ERC20 name of the PerpetualYieldToken of a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"The ERC20 name")))),(0,l.kt)("h3",{id:"perpetualyieldtokensymbol"},"perpetualYieldTokenSymbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function perpetualYieldTokenSymbol(address vault) external view virtual returns (string)\n")),(0,l.kt)("p",null,"Computes the ERC20 symbol of the NegativeYieldToken of a vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to query")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"[0]"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"The ERC20 symbol")))),(0,l.kt)("h3",{id:"beforeperpetualyieldtokentransfer"},"beforePerpetualYieldTokenTransfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function beforePerpetualYieldTokenTransfer(address from, address to, uint256 amount, uint256 fromBalance, uint256 toBalance) external virtual\n")),(0,l.kt)("p",null,"SHOULD NOT BE CALLED BY USERS, ONLY CALLED BY PERPETUAL YIELD TOKEN CONTRACTS"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Called by PYT contracts deployed by this gate before each token transfer, in order to\naccrue the yield earned by the from & to accounts")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"from"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The token transfer from account")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"to"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The token transfer to account")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"amount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"fromBalance"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The token balance of the from account before the transfer")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"toBalance"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The token balance of the to account before the transfer")))),(0,l.kt)("h2",{id:"emergency-exit-functions"},"Emergency exit functions"),(0,l.kt)("h3",{id:"owneractivateemergencyexitforvault"},"ownerActivateEmergencyExitForVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function ownerActivateEmergencyExitForVault(address vault, uint96 pytPriceInUnderlying) external virtual\n")),(0,l.kt)("p",null,"Activates the emergency exit mode for a certain vault. Only callable by owner."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Activating emergency exit allows PYT/NYT holders to do single-sided burns to redeem the underlying\ncollateral. This is to prevent cases where a large portion of PYT/NYT is locked up in a buggy/malicious contract\nand locks up the underlying collateral forever.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to activate emergency exit for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pytPriceInUnderlying"),(0,l.kt)("td",{parentName:"tr",align:null},"uint96"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying asset burning each PYT can redeem. Scaled by PRECISION.")))),(0,l.kt)("h3",{id:"ownerdeactivateemergencyexitforvault"},"ownerDeactivateEmergencyExitForVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function ownerDeactivateEmergencyExitForVault(address vault) external virtual\n")),(0,l.kt)("p",null,"Deactivates the emergency exit mode for a certain vault. Only callable by owner."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to deactivate emergency exit for")))),(0,l.kt)("h3",{id:"emergencyexitnegativeyieldtoken"},"emergencyExitNegativeYieldToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function emergencyExitNegativeYieldToken(address vault, uint256 amount, address recipient) external virtual returns (uint256 underlyingAmount)\n")),(0,l.kt)("p",null,"Emergency exit NYTs into the underlying asset. Only callable when emergency exit has\nbeen activated for the vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to exit NYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"amount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of NYT to exit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the underlying asset")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying asset exited")))),(0,l.kt)("h3",{id:"emergencyexitperpetualyieldtoken"},"emergencyExitPerpetualYieldToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function emergencyExitPerpetualYieldToken(address vault, contract IxPYT xPYT, uint256 amount, address recipient) external virtual returns (uint256 underlyingAmount)\n")),(0,l.kt)("p",null,"Emergency exit PYTs into the underlying asset. Only callable when emergency exit has\nbeen activated for the vault."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to exit PYT for")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"contract IxPYT"),(0,l.kt)("td",{parentName:"tr",align:null},"The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"amount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of PYT to exit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the underlying asset")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying asset exited")))),(0,l.kt)("h2",{id:"internal-functions"},"Internal functions"),(0,l.kt)("h3",{id:"_accrueyield"},"_accrueYield"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _accrueYield(address vault, contract PerpetualYieldToken pyt, address user, uint256 updatedPricePerVaultShare) internal virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Updates the yield earned globally and for a particular user.")),(0,l.kt)("h3",{id:"_enter"},"_enter"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _enter(address nytRecipient, address pytRecipient, address vault, contract IxPYT xPYT, uint256 underlyingAmount, uint256 updatedPricePerVaultShare) internal virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Mints PYTs and NYTs to the recipient given the amount of underlying deposited.")),(0,l.kt)("h3",{id:"_exit"},"_exit"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _exit(address vault, contract IxPYT xPYT, uint256 underlyingAmount, uint256 updatedPricePerVaultShare) internal virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Burns PYTs and NYTs from msg.sender given the amount of underlying withdrawn.")),(0,l.kt)("h3",{id:"_claimyield"},"_claimYield"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _claimYield(address vault, uint256 updatedPricePerVaultShare) internal virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Updates storage variables for when a PYT holder claims the accrued yield.")),(0,l.kt)("h3",{id:"_getclaimableyieldamount"},"_getClaimableYieldAmount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _getClaimableYieldAmount(address vault, address user, uint256 updatedYieldPerToken, uint256 userYieldPerTokenStored_, uint256 userPYTBalance) internal view virtual returns (uint256 yieldAmount)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns the amount of yield claimable by a PerpetualYieldToken holder from a vault.\nAssumes userYieldPerTokenStored")," != 0. Does not account for protocol fees._"),(0,l.kt)("h3",{id:"_depositintovault"},"_depositIntoVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _depositIntoVault(contract ERC20 underlying, uint256 underlyingAmount, address vault) internal virtual\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Deposits underlying tokens into a vault")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlying"),(0,l.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,l.kt)("td",{parentName:"tr",align:null},"The underlying token to deposit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of tokens to deposit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to deposit into")))),(0,l.kt)("h3",{id:"_withdrawfromvault"},"_withdrawFromVault"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _withdrawFromVault(address recipient, address vault, uint256 underlyingAmount, uint256 pricePerVaultShare, bool checkBalance) internal virtual returns (uint256 withdrawnUnderlyingAmount)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Withdraws underlying tokens from a vault")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the underlying tokens")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"vault"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The vault to withdraw from")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"underlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of tokens to withdraw")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pricePerVaultShare"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The latest price per vault share value")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"checkBalance"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to true to withdraw the entire balance if we're trying to withdraw more than the balance (due to rounding errors)")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"withdrawnUnderlyingAmount"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of underlying tokens withdrawn")))),(0,l.kt)("h3",{id:"_vaultsharesamounttounderlyingamount"},"_vaultSharesAmountToUnderlyingAmount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _vaultSharesAmountToUnderlyingAmount(address vault, uint256 vaultSharesAmount, uint256 pricePerVaultShare) internal view virtual returns (uint256)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Converts a vault share amount into an equivalent underlying asset amount")),(0,l.kt)("h3",{id:"_vaultsharesamounttounderlyingamountroundingup"},"_vaultSharesAmountToUnderlyingAmountRoundingUp"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _vaultSharesAmountToUnderlyingAmountRoundingUp(address vault, uint256 vaultSharesAmount, uint256 pricePerVaultShare) internal view virtual returns (uint256)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Converts a vault share amount into an equivalent underlying asset amount, rounding up")),(0,l.kt)("h3",{id:"_underlyingamounttovaultsharesamount"},"_underlyingAmountToVaultSharesAmount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _underlyingAmountToVaultSharesAmount(address vault, uint256 underlyingAmount, uint256 pricePerVaultShare) internal view virtual returns (uint256)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Converts an underlying asset amount into an equivalent vault shares amount")),(0,l.kt)("h3",{id:"_computeyieldpertoken"},"_computeYieldPerToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function _computeYieldPerToken(address vault, contract PerpetualYieldToken pyt, uint256 updatedPricePerVaultShare) internal view virtual returns (uint256)\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Computes the latest yieldPerToken value for a vault.")))}m.isMDXComponent=!0}}]);