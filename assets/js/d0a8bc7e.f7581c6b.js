"use strict";(self.webpackChunktimeless_docs=self.webpackChunktimeless_docs||[]).push([[9429],{3905:function(t,e,a){a.d(e,{Zo:function(){return s},kt:function(){return k}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var i=n.createContext({}),u=function(t){var e=n.useContext(i),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},s=function(t){var e=u(t.components);return n.createElement(i.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},d=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,i=t.parentName,s=p(t,["components","mdxType","originalType","parentName"]),d=u(a),k=r,c=d["".concat(i,".").concat(k)]||d[k]||m[k]||l;return a?n.createElement(c,o(o({ref:e},s),{},{components:a})):n.createElement(c,o({ref:e},s))}));function k(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,o=new Array(l);o[0]=d;var p={};for(var i in e)hasOwnProperty.call(e,i)&&(p[i]=e[i]);p.originalType=t,p.mdxType="string"==typeof t?t:r,o[1]=p;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4954:function(t,e,a){a.r(e),a.d(e,{assets:function(){return s},contentTitle:function(){return i},default:function(){return k},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return m}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),o=["components"],p={},i="UniswapV3Swapper",u={unversionedId:"smart-contracts/swapper/UniswapV3Swapper",id:"smart-contracts/swapper/UniswapV3Swapper",title:"UniswapV3Swapper",description:"GitHub: link",source:"@site/docs/smart-contracts/swapper/UniswapV3Swapper.md",sourceDirName:"smart-contracts/swapper",slug:"/smart-contracts/swapper/UniswapV3Swapper",permalink:"/docs/smart-contracts/swapper/UniswapV3Swapper",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"UniswapV3Juggler",permalink:"/docs/smart-contracts/swapper/UniswapV3Juggler"},next:{title:"Introduction",permalink:"/docs/smart-contracts/xpyt/intro"}},s={},m=[{value:"Errors",id:"errors",level:2},{value:"Error_SameToken",id:"error_sametoken",level:3},{value:"Error_PastDeadline",id:"error_pastdeadline",level:3},{value:"Error_ZeroExSwapFailed",id:"error_zeroexswapfailed",level:3},{value:"Error_InsufficientOutput",id:"error_insufficientoutput",level:3},{value:"Error_ProtocolFeeRecipientIsZero",id:"error_protocolfeerecipientiszero",level:3},{value:"Error_NotUniswapV3Pool",id:"error_notuniswapv3pool",level:3},{value:"Error_BothTokenDeltasAreZero",id:"error_bothtokendeltasarezero",level:3},{value:"Events",id:"events",level:2},{value:"SetProtocolFee",id:"setprotocolfee",level:3},{value:"Structs",id:"structs",level:2},{value:"SwapArgs",id:"swapargs",level:3},{value:"ProtocolFeeInfo",id:"protocolfeeinfo",level:3},{value:"SwapCallbackData",id:"swapcallbackdata",level:3},{value:"Constants",id:"constants",level:2},{value:"MIN_SQRT_RATIO_PLUS_ONE",id:"min_sqrt_ratio_plus_one",level:3},{value:"MAX_SQRT_RATIO_MINUS_ONE",id:"max_sqrt_ratio_minus_one",level:3},{value:"Immutable parameters",id:"immutable-parameters",level:2},{value:"zeroExProxy",id:"zeroexproxy",level:3},{value:"weth",id:"weth",level:3},{value:"uniswapV3Factory",id:"uniswapv3factory",level:3},{value:"State variables",id:"state-variables",level:2},{value:"protocolFeeInfo",id:"protocolfeeinfo-1",level:3},{value:"State-mutating functions",id:"state-mutating-functions",level:2},{value:"swapUnderlyingToNyt",id:"swapunderlyingtonyt",level:3},{value:"swapUnderlyingToXpyt",id:"swapunderlyingtoxpyt",level:3},{value:"swapNytToUnderlying",id:"swapnyttounderlying",level:3},{value:"swapXpytToUnderlying",id:"swapxpyttounderlying",level:3},{value:"doZeroExSwap",id:"dozeroexswap",level:3},{value:"wrapEthInput",id:"wrapethinput",level:3},{value:"Owner functions",id:"owner-functions",level:2},{value:"ownerSetProtocolFee",id:"ownersetprotocolfee",level:3}],d={toc:m};function k(t){var e=t.components,a=(0,r.Z)(t,o);return(0,l.kt)("wrapper",(0,n.Z)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"uniswapv3swapper"},"UniswapV3Swapper"),(0,l.kt)("p",null,"GitHub: ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/timeless-fi/swapper/blob/main/src/uniswap-v3/UniswapV3Swapper.sol"},"link")),(0,l.kt)("p",null,"Swapper that uses Uniswap V3 to swap between xPYTs/NYTs"),(0,l.kt)("h2",{id:"errors"},"Errors"),(0,l.kt)("h3",{id:"error_sametoken"},"Error_SameToken"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_SameToken()\n")),(0,l.kt)("h3",{id:"error_pastdeadline"},"Error_PastDeadline"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_PastDeadline()\n")),(0,l.kt)("h3",{id:"error_zeroexswapfailed"},"Error_ZeroExSwapFailed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_ZeroExSwapFailed()\n")),(0,l.kt)("h3",{id:"error_insufficientoutput"},"Error_InsufficientOutput"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_InsufficientOutput()\n")),(0,l.kt)("h3",{id:"error_protocolfeerecipientiszero"},"Error_ProtocolFeeRecipientIsZero"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_ProtocolFeeRecipientIsZero()\n")),(0,l.kt)("h3",{id:"error_notuniswapv3pool"},"Error_NotUniswapV3Pool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_NotUniswapV3Pool()\n")),(0,l.kt)("h3",{id:"error_bothtokendeltasarezero"},"Error_BothTokenDeltasAreZero"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"error Error_BothTokenDeltasAreZero()\n")),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("h3",{id:"setprotocolfee"},"SetProtocolFee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event SetProtocolFee(struct Swapper.ProtocolFeeInfo protocolFeeInfo_)\n")),(0,l.kt)("h2",{id:"structs"},"Structs"),(0,l.kt)("h3",{id:"swapargs"},"SwapArgs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SwapArgs {\n  contract Gate gate;\n  address vault;\n  contract ERC20 underlying;\n  contract ERC20 nyt;\n  contract ERC20 pyt;\n  contract IxPYT xPYT;\n  uint256 tokenAmountIn;\n  uint256 minAmountOut;\n  address recipient;\n  bool useSwapperBalance;\n  bool usePYT;\n  uint256 deadline;\n  bytes extraArgs;\n}\n")),(0,l.kt)("h3",{id:"protocolfeeinfo"},"ProtocolFeeInfo"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ProtocolFeeInfo {\n  uint8 fee;\n  address recipient;\n}\n")),(0,l.kt)("h3",{id:"swapcallbackdata"},"SwapCallbackData"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct SwapCallbackData {\n  contract ERC20 tokenIn;\n  contract ERC20 tokenOut;\n  uint24 fee;\n}\n")),(0,l.kt)("h2",{id:"constants"},"Constants"),(0,l.kt)("h3",{id:"min_sqrt_ratio_plus_one"},"MIN_SQRT_RATIO_PLUS_ONE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint160 MIN_SQRT_RATIO_PLUS_ONE\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The minimum value that can be returned from #getSqrtRatioAtTick + 1. Equivalent to getSqrtRatioAtTick(MIN_TICK) + 1\nCopied from v3-core/libraries/TickMath.sol")),(0,l.kt)("h3",{id:"max_sqrt_ratio_minus_one"},"MAX_SQRT_RATIO_MINUS_ONE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"uint160 MAX_SQRT_RATIO_MINUS_ONE\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"The maximum value that can be returned from #getSqrtRatioAtTick - 1. Equivalent to getSqrtRatioAtTick(MAX_TICK) - 1\nCopied from v3-core/libraries/TickMath.sol")),(0,l.kt)("h2",{id:"immutable-parameters"},"Immutable parameters"),(0,l.kt)("h3",{id:"zeroexproxy"},"zeroExProxy"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"address zeroExProxy\n")),(0,l.kt)("p",null,"The 0x proxy contract used for 0x swaps"),(0,l.kt)("h3",{id:"weth"},"weth"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"contract WETH weth\n")),(0,l.kt)("p",null,"The Wrapped Ethereum contract"),(0,l.kt)("h3",{id:"uniswapv3factory"},"uniswapV3Factory"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"address uniswapV3Factory\n")),(0,l.kt)("p",null,"The official Uniswap V3 factory address"),(0,l.kt)("h2",{id:"state-variables"},"State variables"),(0,l.kt)("h3",{id:"protocolfeeinfo-1"},"protocolFeeInfo"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Swapper.ProtocolFeeInfo protocolFeeInfo\n")),(0,l.kt)("p",null,"The protocol fee and the fee recipient address."),(0,l.kt)("h2",{id:"state-mutating-functions"},"State-mutating functions"),(0,l.kt)("h3",{id:"swapunderlyingtonyt"},"swapUnderlyingToNyt"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapUnderlyingToNyt(struct Swapper.SwapArgs args) external virtual returns (uint256 tokenAmountOut)\n")),(0,l.kt)("p",null,"Swaps the underlying asset of an NYT into the NYT"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"em"},"extraArg = (uint24 fee)"))),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"fee: The fee tier of the Uniswap V3 pool to use")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"args"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Swapper.SwapArgs"),(0,l.kt)("td",{parentName:"tr",align:null},"The input arguments (see SwapArgs definition)")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token output")))),(0,l.kt)("h3",{id:"swapunderlyingtoxpyt"},"swapUnderlyingToXpyt"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapUnderlyingToXpyt(struct Swapper.SwapArgs args) external virtual returns (uint256 tokenAmountOut)\n")),(0,l.kt)("p",null,"Swaps the underlying asset of an xPYT into the xPYT"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"em"},"extraArg = (uint24 fee)"))),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"fee: The fee tier of the Uniswap V3 pool to use")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"args"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Swapper.SwapArgs"),(0,l.kt)("td",{parentName:"tr",align:null},"The input arguments (see SwapArgs definition)")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token output")))),(0,l.kt)("h3",{id:"swapnyttounderlying"},"swapNytToUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapNytToUnderlying(struct Swapper.SwapArgs args) external virtual returns (uint256 tokenAmountOut)\n")),(0,l.kt)("p",null,"Swaps an NYT to its underlying asset"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"em"},"extraArg = (uint24 fee, uint256 swapAmountIn)"))),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"fee: The fee tier of the Uniswap V3 pool to use")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"swapAmountIn: The amount of NYT to swap to xPYT")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"args"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Swapper.SwapArgs"),(0,l.kt)("td",{parentName:"tr",align:null},"The input arguments (see SwapArgs definition)")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token output")))),(0,l.kt)("h3",{id:"swapxpyttounderlying"},"swapXpytToUnderlying"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swapXpytToUnderlying(struct Swapper.SwapArgs args) external virtual returns (uint256 tokenAmountOut)\n")),(0,l.kt)("p",null,"Swaps an xPYT to its underlying asset"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"em"},"extraArg = (uint24 fee, uint256 swapAmountIn)"))),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"fee: The fee tier of the Uniswap V3 pool to use")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"swapAmountIn: The amount of xPYT to swap to NYT")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"args"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Swapper.SwapArgs"),(0,l.kt)("td",{parentName:"tr",align:null},"The input arguments (see SwapArgs definition)")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token output")))),(0,l.kt)("h3",{id:"dozeroexswap"},"doZeroExSwap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function doZeroExSwap(contract ERC20 tokenIn, uint256 tokenAmountIn, contract ERC20 tokenOut, uint256 minAmountOut, address recipient, bool useSwapperBalance, bool requireApproval, uint256 deadline, bytes swapData) external virtual returns (uint256 tokenAmountOut)\n")),(0,l.kt)("p",null,"Swaps between two regular tokens using 0x."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Used in conjuction with the 0x API ",(0,l.kt)("a",{parentName:"em",href:"https://www.0x.org/docs/api"},"https://www.0x.org/docs/api"))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenIn"),(0,l.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,l.kt)("td",{parentName:"tr",align:null},"The input token")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountIn"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token input")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenOut"),(0,l.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,l.kt)("td",{parentName:"tr",align:null},"The output token")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The minimum acceptable token output amount, used for slippage checking.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"address"),(0,l.kt)("td",{parentName:"tr",align:null},"The recipient of the token output")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"useSwapperBalance"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to true to use the Swapper's token balance as token input")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"requireApproval"),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to true to approve tokenIn to zeroExProxy")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"deadline"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The Unix timestamp (in seconds) after which the call will be reverted")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"swapData"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes"),(0,l.kt)("td",{parentName:"tr",align:null},"The call data to zeroExProxy to execute the swap, obtained from the ",(0,l.kt)("a",{parentName:"td",href:"https://api.0x.org/swap/v1/quote"},"https://api.0x.org/swap/v1/quote")," endpoint")))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tokenAmountOut"),(0,l.kt)("td",{parentName:"tr",align:null},"uint256"),(0,l.kt)("td",{parentName:"tr",align:null},"The amount of token output")))),(0,l.kt)("h3",{id:"wrapethinput"},"wrapEthInput"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function wrapEthInput() external payable\n")),(0,l.kt)("p",null,"Wraps the user's ETH input into WETH"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Should be used as part of a multicall to convert the user's ETH input into WETH\nso that it can be swapped into xPYT/NYT.")),(0,l.kt)("h2",{id:"owner-functions"},"Owner functions"),(0,l.kt)("h3",{id:"ownersetprotocolfee"},"ownerSetProtocolFee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function ownerSetProtocolFee(struct Swapper.ProtocolFeeInfo protocolFeeInfo_) external virtual\n")),(0,l.kt)("p",null,"Updates the protocol fee and/or the protocol fee recipient.\nOnly callable by the owner."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"protocolFeeInfo","_"),(0,l.kt)("td",{parentName:"tr",align:null},"struct Swapper.ProtocolFeeInfo"),(0,l.kt)("td",{parentName:"tr",align:null},"The new protocol fee info")))))}k.isMDXComponent=!0}}]);