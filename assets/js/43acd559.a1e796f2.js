"use strict";(self.webpackChunktimeless_docs=self.webpackChunktimeless_docs||[]).push([[4921],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function p(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=n.createContext({}),c=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):p(p({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(r),d=a,f=m["".concat(i,".").concat(d)]||m[d]||l[d]||o;return r?n.createElement(f,p(p({ref:t},u),{},{components:r})):n.createElement(f,p({ref:t},u))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,p=new Array(o);p[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,p[1]=s;for(var c=2;c<o;c++)p[c]=r[c];return n.createElement.apply(null,p)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},7583:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>p,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const o={sidebar_position:1},p="Introduction",s={unversionedId:"smart-contracts/swapper/intro",id:"smart-contracts/swapper/intro",title:"Introduction",description:"GitHub repo: link",source:"@site/docs/smart-contracts/swapper/intro.md",sourceDirName:"smart-contracts/swapper",slug:"/smart-contracts/swapper/intro",permalink:"/docs/smart-contracts/swapper/intro",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Factory",permalink:"/docs/smart-contracts/core/Factory"},next:{title:"Swapper",permalink:"/docs/smart-contracts/swapper/Swapper-Contract"}},i={},c=[],u={toc:c};function l(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"GitHub repo: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/timeless-fi/swapper"},"link")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"./Swapper-Contract"},"Swapper")," is an abstract contract that defines the interface traders use to swap between xPYTs/PYTs/NYTs and their underlying assets. It also supports using ",(0,a.kt)("a",{parentName:"p",href:"https://0x.org"},"0x")," as an intermediate step during a swap."),(0,a.kt)("p",null,"Implementations of ",(0,a.kt)("inlineCode",{parentName:"p"},"Swapper")," each support an underlying exchange protocol. Currently, only ",(0,a.kt)("a",{parentName:"p",href:"./UniswapV3Swapper"},"UniswapV3Swapper")," is implemented."),(0,a.kt)("p",null,"The only type of swap that's currently not supported is swapping between PYT\u27f7NYT, because swapping between xPYT\u27f7NYT is done directly using Uniswap, therefore we cannot include converting xPYT\u27f7PYT in the same transaction."),(0,a.kt)("p",null,"Furthermore, when swapping from xPYT/PYT/NYT to the underlying asset using ",(0,a.kt)("inlineCode",{parentName:"p"},"UniswapV3Swapper"),", you need to use ",(0,a.kt)("a",{parentName:"p",href:"./uniswapv3juggler"},"UniswapV3Juggler")," to determine ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/timeless-fi/swapper/blob/main/src/uniswap-v3/UniswapV3Swapper.sol#L279="},(0,a.kt)("inlineCode",{parentName:"a"},"swapAmountIn")),", which is the amount of input token to swap with using the Uniswap v3 such that the swapper ends up with an equal amount of PYT and NYT (which is then burnt to recover the underlying assets)."))}l.isMDXComponent=!0}}]);