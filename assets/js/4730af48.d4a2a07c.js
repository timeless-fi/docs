"use strict";(self.webpackChunktimeless_docs=self.webpackChunktimeless_docs||[]).push([[5031],{3905:(t,e,n)=>{n.d(e,{Zo:()=>m,kt:()=>d});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function p(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var o=a.createContext({}),u=function(t){var e=a.useContext(o),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},m=function(t){var e=u(t.components);return a.createElement(o.Provider,{value:e},t.children)},s={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,o=t.parentName,m=p(t,["components","mdxType","originalType","parentName"]),c=u(n),d=r,k=c["".concat(o,".").concat(d)]||c[d]||s[d]||l;return n?a.createElement(k,i(i({ref:e},m),{},{components:n})):a.createElement(k,i({ref:e},m))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=c;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=t,p.mdxType="string"==typeof t?t:r,i[1]=p;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4637:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>s,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={},i="UniswapV3Juggler",p={unversionedId:"smart-contracts/swapper/UniswapV3Juggler",id:"smart-contracts/swapper/UniswapV3Juggler",title:"UniswapV3Juggler",description:"GitHub: link",source:"@site/docs/smart-contracts/swapper/UniswapV3Juggler.md",sourceDirName:"smart-contracts/swapper",slug:"/smart-contracts/swapper/UniswapV3Juggler",permalink:"/docs/smart-contracts/swapper/UniswapV3Juggler",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Swapper",permalink:"/docs/smart-contracts/swapper/Swapper-Contract"},next:{title:"UniswapV3Swapper",permalink:"/docs/smart-contracts/swapper/UniswapV3Swapper"}},o={},u=[{value:"Constants",id:"constants",level:2},{value:"MIN_SQRT_RATIO_PLUS_ONE",id:"min_sqrt_ratio_plus_one",level:3},{value:"MAX_SQRT_RATIO_MINUS_ONE",id:"max_sqrt_ratio_minus_one",level:3},{value:"MAX_BINARY_SEARCH_ITERATIONS",id:"max_binary_search_iterations",level:3},{value:"Immutable parameters",id:"immutable-parameters",level:2},{value:"factory",id:"factory",level:3},{value:"quoter",id:"quoter",level:3},{value:"Public functions",id:"public-functions",level:2},{value:"juggleXpytInput",id:"jugglexpytinput",level:3},{value:"juggleNytInput",id:"jugglenytinput",level:3}],m={toc:u};function s(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"uniswapv3juggler"},"UniswapV3Juggler"),(0,r.kt)("p",null,"GitHub: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/timeless-fi/swapper/blob/main/src/uniswap-v3/UniswapV3Juggler.sol"},"link")),(0,r.kt)("p",null,"Given xPYT/NYT input, computes how much to swap to result in\nan equal amount of PYT & NYT."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Used in conjunction with UniswapV3Swapper::swapNytToUnderlying() and\nUniswapV3Swapper::swapXpytToUnderlying(). Should only be called offchain since\nthe gas cost is too high to be called onchain.")),(0,r.kt)("h2",{id:"constants"},"Constants"),(0,r.kt)("h3",{id:"min_sqrt_ratio_plus_one"},"MIN_SQRT_RATIO_PLUS_ONE"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"uint160 MIN_SQRT_RATIO_PLUS_ONE\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The minimum value that can be returned from #getSqrtRatioAtTick + 1. Equivalent to getSqrtRatioAtTick(MIN_TICK) + 1\nCopied from v3-core/libraries/TickMath.sol")),(0,r.kt)("h3",{id:"max_sqrt_ratio_minus_one"},"MAX_SQRT_RATIO_MINUS_ONE"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"uint160 MAX_SQRT_RATIO_MINUS_ONE\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The maximum value that can be returned from #getSqrtRatioAtTick - 1. Equivalent to getSqrtRatioAtTick(MAX_TICK) - 1\nCopied from v3-core/libraries/TickMath.sol")),(0,r.kt)("h3",{id:"max_binary_search_iterations"},"MAX_BINARY_SEARCH_ITERATIONS"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 MAX_BINARY_SEARCH_ITERATIONS\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The maximum number of binary search iterations to find swapAmountIn")),(0,r.kt)("h2",{id:"immutable-parameters"},"Immutable parameters"),(0,r.kt)("h3",{id:"factory"},"factory"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"address factory\n")),(0,r.kt)("p",null,"The official Uniswap V3 factory address"),(0,r.kt)("h3",{id:"quoter"},"quoter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract IQuoter quoter\n")),(0,r.kt)("p",null,"The Uniswap V3 Quoter deployment"),(0,r.kt)("h2",{id:"public-functions"},"Public functions"),(0,r.kt)("h3",{id:"jugglexpytinput"},"juggleXpytInput"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function juggleXpytInput(contract ERC20 nyt, contract ERC4626 xPYT, uint24 fee, uint256 tokenAmountIn, uint256 maxError) external returns (uint256 swapAmountIn)\n")),(0,r.kt)("p",null,"Given xPYT input, compute how much xPYT to swap into NYT to result in\nan equal amount of PYT & NYT."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nyt"),(0,r.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,r.kt)("td",{parentName:"tr",align:null},"The NYT contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,r.kt)("td",{parentName:"tr",align:null},"contract ERC4626"),(0,r.kt)("td",{parentName:"tr",align:null},"The xPYT contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fee"),(0,r.kt)("td",{parentName:"tr",align:null},"uint24"),(0,r.kt)("td",{parentName:"tr",align:null},"The fee tier of the Uniswap V3 pool to use")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenAmountIn"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of token input")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"maxError"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The maximum acceptable difference between the resulting PYT & NYT balances. Might not be achieved if MAX_BINARY_SEARCH_ITERATIONS is reached.")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapAmountIn"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of xPYT to swap into NYT")))),(0,r.kt)("h3",{id:"jugglenytinput"},"juggleNytInput"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function juggleNytInput(contract ERC20 nyt, contract ERC4626 xPYT, uint24 fee, uint256 tokenAmountIn, uint256 maxError) external returns (uint256 swapAmountIn)\n")),(0,r.kt)("p",null,"Given NYT input, compute how much NYT to swap into xPYT to result in\nan equal amount of PYT & NYT."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nyt"),(0,r.kt)("td",{parentName:"tr",align:null},"contract ERC20"),(0,r.kt)("td",{parentName:"tr",align:null},"The NYT contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xPYT"),(0,r.kt)("td",{parentName:"tr",align:null},"contract ERC4626"),(0,r.kt)("td",{parentName:"tr",align:null},"The xPYT contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fee"),(0,r.kt)("td",{parentName:"tr",align:null},"uint24"),(0,r.kt)("td",{parentName:"tr",align:null},"The fee tier of the Uniswap V3 pool to use")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tokenAmountIn"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of token input")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"maxError"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The maximum acceptable difference between the resulting PYT & NYT balances. Might not be achieved if MAX_BINARY_SEARCH_ITERATIONS is reached.")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapAmountIn"),(0,r.kt)("td",{parentName:"tr",align:null},"uint256"),(0,r.kt)("td",{parentName:"tr",align:null},"The amount of NYT to swap into xPYT")))))}s.isMDXComponent=!0}}]);