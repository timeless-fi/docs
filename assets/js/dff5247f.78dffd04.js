"use strict";(self.webpackChunkbunni_docs=self.webpackChunkbunni_docs||[]).push([[5444],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,k=u["".concat(s,".").concat(h)]||u[h]||m[h]||l;return n?i.createElement(k,r(r({ref:t},d),{},{components:n})):i.createElement(k,r({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const l={title:"Parameter Formats",hide_table_of_contents:!1,sidebar_position:3},r="Parameter Formats",o={unversionedId:"v2/technical/ldf/params",id:"v2/technical/ldf/params",title:"Parameter Formats",description:"Each LDF contract receives bytes32 ldfParams when called and has different formats for decoding the actual parameters. Below are how each LDF contract encodes its parameters.",source:"@site/docs/v2/technical/ldf/params.md",sourceDirName:"v2/technical/ldf",slug:"/v2/technical/ldf/params",permalink:"/docs/v2/technical/ldf/params",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Parameter Formats",hide_table_of_contents:!1,sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ILiquidityDensityFunction",permalink:"/docs/v2/technical/ldf/ildf"},next:{title:"Ethereum Deployments",permalink:"/docs/v2/technical/deployments/ethereum"}},s={},p=[{value:"<code>GeometricDistribution</code>",id:"geometricdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding",level:3},{value:"Important Notes",id:"important-notes",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"<code>UniformDistribution</code>",id:"uniformdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding-1",level:3},{value:"Important Notes",id:"important-notes-1",level:3},{value:"Example Usage",id:"example-usage-1",level:3},{value:"<code>DoubleGeometricDistribution</code>",id:"doublegeometricdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding-2",level:3},{value:"Important Notes",id:"important-notes-2",level:3},{value:"Example Usage",id:"example-usage-2",level:3},{value:"<code>CarpetedGeometricDistribution</code>",id:"carpetedgeometricdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding-3",level:3},{value:"Important Notes",id:"important-notes-3",level:3},{value:"Example Usage",id:"example-usage-3",level:3},{value:"<code>CarpetedDoubleGeometricDistribution</code>",id:"carpeteddoublegeometricdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding-4",level:3},{value:"Important Notes",id:"important-notes-4",level:3},{value:"Example Usage",id:"example-usage-4",level:3},{value:"<code>BuyTheDipGeometricDistribution</code>",id:"buythedipgeometricdistribution",level:2},{value:"Parameter Encoding",id:"parameter-encoding-5",level:3},{value:"Important Notes",id:"important-notes-5",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"parameter-formats"},"Parameter Formats"),(0,a.kt)("p",null,"Each LDF contract receives ",(0,a.kt)("inlineCode",{parentName:"p"},"bytes32 ldfParams")," when called and has different formats for decoding the actual parameters. Below are how each LDF contract encodes its parameters."),(0,a.kt)("h2",{id:"geometricdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"GeometricDistribution")),(0,a.kt)("h3",{id:"parameter-encoding"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | offset (3 bytes) | length (2 bytes) | alpha (4 bytes) | unused (22 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (0 for BOTH, 1 for LEFT, 2 for RIGHT, 3 for STATIC)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"offset")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the offset applied to the TWAP tick to get the minTick. In ticks, not ricks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the geometric distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (22 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The actual ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is calculated as ",(0,a.kt)("inlineCode",{parentName:"li"},"roundTickSingle(twapTick + offset, tickSpacing)")," when ",(0,a.kt)("inlineCode",{parentName:"li"},"shiftMode")," is not STATIC."),(0,a.kt)("li",{parentName:"ol"},"For STATIC mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," represents the absolute ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," and must be aligned to tickSpacing."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," value is scaled by ",(0,a.kt)("inlineCode",{parentName:"li"},"Q96 / ALPHA_BASE")," internally. ",(0,a.kt)("inlineCode",{parentName:"li"},"ALPHA_BASE")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"1e8"),"."),(0,a.kt)("li",{parentName:"ol"},"The distribution is bounded to be within the range of usable ticks. If ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is outside this range, it will be adjusted accordingly.")),(0,a.kt)("h3",{id:"example-usage"},"Example Usage"),(0,a.kt)("p",null,"Here's an example of how to encode the parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function encodeParams(\n    ShiftMode shiftMode,\n    int24 offset,\n    int16 length,\n    uint32 alpha\n) pure returns (bytes32) {\n    return abi.encodePacked(uint8(shiftMode), offset, length, alpha);\n}\n")),(0,a.kt)("p",null,"Remember to ensure that all values are within their appropriate ranges and that ",(0,a.kt)("inlineCode",{parentName:"p"},"minTick")," is aligned with ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," for STATIC mode."),(0,a.kt)("h2",{id:"uniformdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"UniformDistribution")),(0,a.kt)("h3",{id:"parameter-encoding-1"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," for the UniformDistribution are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | tickLower (3 bytes) | tickUpper (3 bytes) | unused (25 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (3 for STATIC, as Uniform distribution is always static)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"tickLower")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the lower tick of the distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"tickUpper")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the upper tick of the distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (25 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes-1"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Both ",(0,a.kt)("inlineCode",{parentName:"li"},"tickLower")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"tickUpper")," must be within the range of valid ticks for the pool."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"tickLower")," must be less than ",(0,a.kt)("inlineCode",{parentName:"li"},"tickUpper"),"."),(0,a.kt)("li",{parentName:"ol"},"The ticks need to be aligned to the tick spacing.")),(0,a.kt)("h3",{id:"example-usage-1"},"Example Usage"),(0,a.kt)("p",null,"Here's an example of how to encode the parameters for a uniform distribution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function encodeParams(\n    int24 tickLower,\n    int24 tickUpper\n) pure returns (bytes32) {\n    return abi.encodePacked(uint8(3), tickLower, tickUpper);\n}\n")),(0,a.kt)("p",null,"Remember to ensure that ",(0,a.kt)("inlineCode",{parentName:"p"},"tickLower")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"tickUpper")," are within the valid range of ticks for the pool, ",(0,a.kt)("inlineCode",{parentName:"p"},"tickLower")," is less than ",(0,a.kt)("inlineCode",{parentName:"p"},"tickUpper")," and they're both aligned to the tick spacing."),(0,a.kt)("h2",{id:"doublegeometricdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"DoubleGeometricDistribution")),(0,a.kt)("h3",{id:"parameter-encoding-2"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | offset (3 bytes) | length0 (2 bytes) | alpha0 (4 bytes) | weight0 (4 bytes) | length1 (2 bytes) | alpha1 (4 bytes) | weight1 (4 bytes) | unused (8 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (0 for BOTH, 1 for LEFT, 2 for RIGHT, 3 for STATIC)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"offset")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the offset applied to the TWAP tick to get the minTick. In ticks, not ricks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length0")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the right distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha0")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the right distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weight0")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the right distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length1")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the left distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha1")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the left distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weight1")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the left distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (8 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes-2"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The actual ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is calculated as ",(0,a.kt)("inlineCode",{parentName:"li"},"roundTickSingle(twapTick + offset, tickSpacing)")," when ",(0,a.kt)("inlineCode",{parentName:"li"},"shiftMode")," is not STATIC."),(0,a.kt)("li",{parentName:"ol"},"For STATIC mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," represents the absolute ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," and must be aligned to tickSpacing."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha1")," values are scaled by ",(0,a.kt)("inlineCode",{parentName:"li"},"Q96 / ALPHA_BASE")," internally. ",(0,a.kt)("inlineCode",{parentName:"li"},"ALPHA_BASE")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"1e8"),"."),(0,a.kt)("li",{parentName:"ol"},"The distribution is bounded to be within the range of usable ticks. If ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is outside this range, it will be adjusted accordingly."),(0,a.kt)("li",{parentName:"ol"},"The total length of the distribution is ",(0,a.kt)("inlineCode",{parentName:"li"},"length0 + length1"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"weight0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"weight1")," don't use any particular number of decimals, they're relative weights. For example, ",(0,a.kt)("inlineCode",{parentName:"li"},"weight0")," can be ",(0,a.kt)("inlineCode",{parentName:"li"},"8")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"weight1")," can be ",(0,a.kt)("inlineCode",{parentName:"li"},"2"),", and the respective weights would be ",(0,a.kt)("inlineCode",{parentName:"li"},"8 / 10 = 80%")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"2 / 10 = 20%"),"."),(0,a.kt)("li",{parentName:"ol"},"The minimum liquidity density of each geometric part must be greater than ",(0,a.kt)("inlineCode",{parentName:"li"},"MIN_LIQUIDITY_DENSITY")," (Q96 / 1e3).")),(0,a.kt)("h3",{id:"example-usage-2"},"Example Usage"),(0,a.kt)("p",null,"Here's an example of how to encode the parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function encodeParams(\n    ShiftMode shiftMode,\n    int24 offset,\n    int16 length0,\n    uint32 alpha0,\n    uint32 weight0,\n    int16 length1,\n    uint32 alpha1,\n    uint32 weight1\n) pure returns (bytes32) {\n    return abi.encodePacked(uint8(shiftMode), offset, length0, alpha0, weight0, length1, alpha1, weight1);\n}\n")),(0,a.kt)("p",null,"Remember to ensure that all values are within their appropriate ranges and that ",(0,a.kt)("inlineCode",{parentName:"p"},"minTick")," is aligned with ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," for STATIC mode."),(0,a.kt)("h2",{id:"carpetedgeometricdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"CarpetedGeometricDistribution")),(0,a.kt)("h3",{id:"parameter-encoding-3"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | offset (3 bytes) | length (2 bytes) | alpha (4 bytes) | weightMain (4 bytes) | unused (18 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (0 for BOTH, 1 for LEFT, 2 for RIGHT, 3 for STATIC)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"offset")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the offset applied to the TWAP tick to get the minTick. In ticks, not ricks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the geometric distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the geometric distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weightMain")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the main (geometric) distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (18 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes-3"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The actual ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is calculated as ",(0,a.kt)("inlineCode",{parentName:"li"},"roundTickSingle(twapTick + offset, tickSpacing)")," when ",(0,a.kt)("inlineCode",{parentName:"li"},"shiftMode")," is not STATIC."),(0,a.kt)("li",{parentName:"ol"},"For STATIC mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," represents the absolute ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," and must be aligned to tickSpacing."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," value is scaled by ",(0,a.kt)("inlineCode",{parentName:"li"},"Q96 / ALPHA_BASE")," internally. ",(0,a.kt)("inlineCode",{parentName:"li"},"ALPHA_BASE")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"1e8"),"."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"weightMain")," value uses 9 decimals (i.e., a ",(0,a.kt)("inlineCode",{parentName:"li"},"weightMain")," of 500000000 represents 0.5 or 50%)."),(0,a.kt)("li",{parentName:"ol"},"The distribution is bounded to be within the range of usable ticks. If ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is outside this range, it will be adjusted accordingly."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"weightMain")," must be non-zero and less than ",(0,a.kt)("inlineCode",{parentName:"li"},"WEIGHT_BASE")," (1e9)."),(0,a.kt)("li",{parentName:"ol"},"The minimum liquidity density of the geometric part must be greater than ",(0,a.kt)("inlineCode",{parentName:"li"},"MIN_LIQUIDITY_DENSITY")," (Q96 / 1e3).")),(0,a.kt)("h3",{id:"example-usage-3"},"Example Usage"),(0,a.kt)("p",null,"Here's an example of how to encode the parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function encodeParams(\n    ShiftMode shiftMode,\n    int24 offset,\n    int16 length,\n    uint32 alpha,\n    uint32 weightMain\n) pure returns (bytes32) {\n    return abi.encodePacked(uint8(shiftMode), offset, length, alpha, weightMain);\n}\n")),(0,a.kt)("p",null,"Remember to ensure that all values are within their appropriate ranges and that ",(0,a.kt)("inlineCode",{parentName:"p"},"minTick")," is aligned with ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," for STATIC mode."),(0,a.kt)("h2",{id:"carpeteddoublegeometricdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"CarpetedDoubleGeometricDistribution")),(0,a.kt)("h3",{id:"parameter-encoding-4"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | offset (3 bytes) | length0 (2 bytes) | alpha0 (4 bytes) | weight0 (4 bytes) | length1 (2 bytes) | alpha1 (4 bytes) | weight1 (4 bytes) | weightMain (4 bytes) | unused (4 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (0 for BOTH, 1 for LEFT, 2 for RIGHT, 3 for STATIC)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"offset")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the offset applied to the TWAP tick to get the minTick. In ticks, not ricks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length0")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the right distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha0")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the right distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weight0")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the right distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length1")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the left distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha1")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the left distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weight1")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the left distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"weightMain")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the weight of the main (double geometric) distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (4 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes-4"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The actual ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is calculated as ",(0,a.kt)("inlineCode",{parentName:"li"},"roundTickSingle(twapTick + offset, tickSpacing)")," when ",(0,a.kt)("inlineCode",{parentName:"li"},"shiftMode")," is not STATIC."),(0,a.kt)("li",{parentName:"ol"},"For STATIC mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," represents the absolute ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," and must be aligned to tickSpacing."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha1")," values are scaled by ",(0,a.kt)("inlineCode",{parentName:"li"},"Q96 / ALPHA_BASE")," internally. ",(0,a.kt)("inlineCode",{parentName:"li"},"ALPHA_BASE")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"1e8"),"."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"weightMain")," value uses 9 decimals (i.e., a value of 500000000 represents 0.5 or 50%)."),(0,a.kt)("li",{parentName:"ol"},"The distribution is bounded to be within the range of usable ticks. If ",(0,a.kt)("inlineCode",{parentName:"li"},"minTick")," is outside this range, it will be adjusted accordingly."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"weightMain")," must be non-zero and less than ",(0,a.kt)("inlineCode",{parentName:"li"},"WEIGHT_BASE")," (1e9)."),(0,a.kt)("li",{parentName:"ol"},"The minimum liquidity density of each geometric part must be greater than ",(0,a.kt)("inlineCode",{parentName:"li"},"MIN_LIQUIDITY_DENSITY")," (Q96 / 1e3)."),(0,a.kt)("li",{parentName:"ol"},"The total length of the distribution is ",(0,a.kt)("inlineCode",{parentName:"li"},"length0 + length1"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"weight0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"weight1")," don't use any particular number of decimals, they're relative weights. For example, ",(0,a.kt)("inlineCode",{parentName:"li"},"weight0")," can be ",(0,a.kt)("inlineCode",{parentName:"li"},"8")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"weight1")," can be ",(0,a.kt)("inlineCode",{parentName:"li"},"2"),", and the respective weights would be ",(0,a.kt)("inlineCode",{parentName:"li"},"8 / 10 = 80%")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"2 / 10 = 20%"),".")),(0,a.kt)("h3",{id:"example-usage-4"},"Example Usage"),(0,a.kt)("p",null,"Here's an example of how to encode the parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function encodeParams(\n    ShiftMode shiftMode,\n    int24 offset,\n    int16 length0,\n    uint32 alpha0,\n    uint32 weight0,\n    int16 length1,\n    uint32 alpha1,\n    uint32 weight1,\n    uint32 weightMain\n) pure returns (bytes32) {\n    return abi.encodePacked(uint8(shiftMode), offset, length0, alpha0, weight0, length1, alpha1, weight1, weightMain);\n}\n")),(0,a.kt)("p",null,"Remember to ensure that all values are within their appropriate ranges and that ",(0,a.kt)("inlineCode",{parentName:"p"},"minTick")," is aligned with ",(0,a.kt)("inlineCode",{parentName:"p"},"tickSpacing")," for STATIC mode."),(0,a.kt)("h2",{id:"buythedipgeometricdistribution"},(0,a.kt)("inlineCode",{parentName:"h2"},"BuyTheDipGeometricDistribution")),(0,a.kt)("h3",{id:"parameter-encoding-5"},"Parameter Encoding"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ldfParams")," are encoded as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"| shiftMode (1 byte) | minTick (3 bytes) | length (2 bytes) | alpha (4 bytes) | unused (1 byte) | altAlpha (4 bytes) | altThreshold (3 bytes) | altThresholdDirection (1 byte) | unused (13 bytes) |\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"shiftMode")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value representing the shift mode (3 for STATIC, as this distribution is always static)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"minTick")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the minimum tick of the distribution. Must be aligned to tickSpacing."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"length")," (2 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int16")," value representing the length of the distribution in number of rounded ticks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"alpha")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alpha parameter of the geometric distribution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (1 byte): An unused byte, should be set to zero."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"altAlpha")," (4 bytes): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint32")," value representing the alternative alpha parameter."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"altThreshold")," (3 bytes): An ",(0,a.kt)("inlineCode",{parentName:"li"},"int24")," value representing the threshold for switching between alpha and altAlpha."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"altThresholdDirection")," (1 byte): A ",(0,a.kt)("inlineCode",{parentName:"li"},"uint8")," value (0 or 1) indicating the direction of the threshold comparison."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"unused")," (13 bytes): Unused bytes, should be set to zero.")),(0,a.kt)("h3",{id:"important-notes-5"},"Important Notes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"This distribution always uses TWAP, so there's no dynamic/static distinction like in other distributions."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"altAlpha")," values are scaled by ",(0,a.kt)("inlineCode",{parentName:"li"},"Q96 / ALPHA_BASE")," internally. ",(0,a.kt)("inlineCode",{parentName:"li"},"ALPHA_BASE")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"1e8"),"."),(0,a.kt)("li",{parentName:"ol"},"The distribution switches between ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"altAlpha")," based on the TWAP tick and ",(0,a.kt)("inlineCode",{parentName:"li"},"altThreshold"),"."),(0,a.kt)("li",{parentName:"ol"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"altThresholdDirection")," is true, ",(0,a.kt)("inlineCode",{parentName:"li"},"altAlpha")," is used when ",(0,a.kt)("inlineCode",{parentName:"li"},"twapTick <= altThreshold"),". If false, ",(0,a.kt)("inlineCode",{parentName:"li"},"altAlpha")," is used when ",(0,a.kt)("inlineCode",{parentName:"li"},"twapTick >= altThreshold"),"."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"altAlpha")," must be on different sides of 1 (i.e., one < 1 and one > 1)."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"altThreshold")," must be within the range ",(0,a.kt)("inlineCode",{parentName:"li"},"(minTick, minTick + length * tickSpacing)"),"."),(0,a.kt)("li",{parentName:"ol"},"The distribution is bounded to be within the range of usable ticks.")))}m.isMDXComponent=!0}}]);